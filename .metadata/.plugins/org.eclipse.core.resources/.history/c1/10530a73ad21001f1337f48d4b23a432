package com.example.logviewe.service;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.logviewe.param.BattleAreaDto;
import com.example.logviewe.param.CardDto;
import com.example.logviewe.param.FieldDto;
import com.example.logviewe.param.GameInfo;
import com.example.logviewe.param.Hand;
import com.example.logviewe.param.PlayerDto;
import com.example.logviewe.param.TurnList;
import com.example.logviewe.utils.StrUtil;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;

@Service
public class LogAnalayzer {
	PokeApiService pokeApiService;
	Logger logger = LoggerFactory.getLogger(LogAnalayzer.class);
	
	private List<String> blogList;
	
	private final String DRAW7OP = " drew 7 cards for the opening hand.";
	private final String CARDMAKR = "   • ";
	private final String DFIRST = " decided to go first.";
	private final String DSECOND = " decided to go second.";
	private final String TOACTIVESP = " to the Active Spot.";
	private final String TOBENCH = " to the Bench.";
	private final String PLAYED = " played ";
	private final String TURN1 = "Turn # 1";
	private final String TURN_PREFIX = "Turn # ";
	private final String TURN_AFTER = " - ";
	
	@Autowired
	public LogAnalayzer(PokeApiService pokeApiService) {
		this.pokeApiService = pokeApiService;
	}
	public void Initialize(List<String> blogList) {
		this.blogList = blogList;
	}
	/**
	 * プレイヤー名を取得する
	 * @return
	 */
	public PlayerDto getPlayerNames(){
		PlayerDto playerdto = new PlayerDto();
		
		int num = 0;
		//プレイヤー名を抜き出す
		for(int i=0; i<blogList.size() && num < 2;i++) {
			String line = blogList.get(i);
			if( line.endsWith(DRAW7OP)) {
				String name = line.replace(DRAW7OP, "");
				//2行したにカードの種類があれば、自分
				String mark = blogList.get(i+2);
				if( mark.startsWith(CARDMAKR)) {
					playerdto.setMyName( name );
					num++;
				}else {
					playerdto.setOppName(name);
					num++;
				}
			}
		}
		//先攻後攻を検知する
		for(String str : blogList) {
			if( str.endsWith(DFIRST) ) {
				//先行をとった人は・・・
				String name = str.replace(DFIRST,"");
				playerdto.setFirst( (name.equals(playerdto.getMyName())) );
			}else if(str.endsWith(DSECOND)) {
				//後攻を取った人は・・・
				String name = str.replace(DSECOND,"");
				playerdto.setFirst( !(name.equals(playerdto.getMyName())) );
			}
		}
		
		return playerdto;
	}
	
	/**
	 * 
	 * @return
	 * @throws JsonProcessingException 
	 * @throws JsonMappingException 
	 */
	public Hand getFirstHand(String myName) throws JsonMappingException, JsonProcessingException {
		Hand hand = new Hand();
		//初手の７枚を探す
		String firstHandMsg = myName + DRAW7OP;
		String cards = "";
		for(int i=0; i<blogList.size();i++) {
			String line = blogList.get(i);
			if( line.equals(firstHandMsg)) {
				cards = blogList.get(i+2);
				cards = cards.replace(CARDMAKR, "");
				break;
			}
		}
		
		//カンマ区切りの七枚を取得する
		String[] cardarry = cards.split(",");
		for( String cardname : cardarry) {
			hand.addCard( getCardDto(cardname) );
		}
		
		return hand;
	}
	
	/**
	 * 対戦準備処理（バトル場とベンチへのセット）
	 * @param myName
	 * @param oppName
	 * @return
	 */
	public GameInfo getInitilaize(GameInfo gameInfo) {
		String myName = gameInfo.getPlayers().getMyName();
		String oppName = gameInfo.getPlayers().getOppName();
		FieldDto field = new FieldDto();
		BattleAreaDto myArea = new BattleAreaDto();
		BattleAreaDto oppArea = new BattleAreaDto();
		String pName;
		//自分のバトル場を取得する
		String myStartStr = myName + PLAYED;
		String oppStartStr = oppName + PLAYED;
		
		boolean turn1Flag = false;
		for(int i=0; i<blogList.size()&& !turn1Flag;i++) {
			String line = blogList.get(i);
			if( line.startsWith(myStartStr)&& 
					line.endsWith(TOACTIVESP)) {
				//自分のバトル場
				pName = StrUtil.removeStr(line,new String[]{myStartStr,TOACTIVESP});
				myArea.setBattlefield(getCardDto(pName));
			}else if(line.startsWith(oppStartStr)&& 
					line.endsWith(TOACTIVESP)) {
				//相手のバトル場
				pName = StrUtil.removeStr(line,new String[]{oppStartStr,TOACTIVESP});
				oppArea.setBattlefield(getCardDto(pName));
				
			}else if( line.startsWith(myStartStr)&& 
					line.endsWith(TOBENCH)) {
				//自分のベンチ
				pName = StrUtil.removeStr(line,new String[]{myStartStr,TOBENCH});
				myArea.adddBechField(getCardDto(pName));
			}else if(line.startsWith(oppStartStr)&& 
					line.endsWith(TOBENCH)) {
				//相手のベンチ
				pName = StrUtil.removeStr(line,new String[]{oppStartStr,TOBENCH});
				oppArea.adddBechField(getCardDto(pName));
			}else if(line.startsWith(TURN1)) {
				turn1Flag = true;
			}
		}
		
		field.setMyArea(myArea);
		field.setOppArea(oppArea);
		gameInfo.setField(field);
		
		//バトル場にだしカードを手札から消す
		gameInfo.getHand().removeCard(myArea.getBattlefield());
		removeCard(gameInfo.getHand(),myArea.getBenchfield());
		
		return gameInfo;
	}
	
	/**
	 * 手札を削除する
	 * @param srcHand
	 * @param cardList
	 * @return
	 */
	public Hand removeCard(Hand srcHand,List<CardDto> cardList) {
		if( cardList == null ) {
			return srcHand;
		}
		for(CardDto card : cardList) {
			srcHand.removeCard(card);
		}
		return srcHand;
	}
	
	public TurnList getTurnList() {
		TurnList turnList = new TurnList();
		int turn = 1;
		boolean firstFlg = true;
		for(String str : blogList) {
			String turnStr = TURN_PREFIX + turn + TURN_AFTER;
			if( str.startsWith(turnStr)) {
				logger.info("ターン;"+str);
				if( !firstFlg ) {
					turn++;
				}
				firstFlg = !firstFlg;
			}
		}
		return turnList;
	}
	
	private CardDto getCardDto(String cardname) {
		CardDto card = new CardDto();
		cardname = cardname.trim();
		String imgPath;
		
		try {
			imgPath = pokeApiService.findSmallImage(cardname);
			card.setName(cardname);
			card.setImgPath(imgPath);
		} catch (JsonProcessingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			card.setName("");
		}

		return card;
	}
}
